Last login: Tue Nov 18 20:18:57 on ttys000
airbears2-10-142-152-197:~ jingezhang$ ssh cs161-hc@hive11.cs.berkeley.edu
cs161-hc@hive11.cs.berkeley.edu's password: 
Welcome to Ubuntu 12.04.4 LTS (GNU/Linux 3.2.0-61-generic x86_64)

 * Documentation:  https://help.ubuntu.com/

New release '14.04.1 LTS' available.
Run 'do-release-upgrade' to upgrade to it.

Last login: Tue Nov 18 20:19:00 2014 from airbears2-10-142-152-197.airbears2.1918.berkeley.edu

'cs161-hc' is using 111/2048 MB (5%) of its disk quota on /home/cc.

'cs161-hc' is using 0/20971 MB (0%) of its disk quota on /home/tmp.

(Type 'more /share/b/pub/disk.quotas' for more information.)

hive11 [501] ~ # cd TLS-Implementation/
hive11 [502] ~/TLS-Implementation # cd tlsproject/
hive11 [503] ~/TLS-Implementation/tlsproject # make
gcc -W aes.c sha256.c client.c -o client -lgmp
hive11 [504] ~/TLS-Implementation/tlsproject # ./client -i 54.148.53.246 -c client_cert.crt -d client_private.key -m client_modulus.key 
hello
^C
hive11 [505] ~/TLS-Implementation/tlsproject # ./client -i 54.148.53.246 -c client_cert.crt -d client_private.key -m client_modulus.key 
hellow
Hooray!
few
Hooray!
fewf
Hooray!
we
Hooray!
fw
eHooray!
f
Hooray!
we
fHooray!
w
eHooray!
f
wHooray!
ef
ewHooray!

fHooray!
we
Hooray!
f
wHooray!
e^C
hive11 [506] ~/TLS-Implementation/tlsproject # mkdir submit
hive11 [507] ~/TLS-Implementation/tlsproject # cp client.c tlsproj.txt submit/
hive11 [508] ~/TLS-Implementation/tlsproject # cd submit/
hive11 [509] ~/TLS-Implementation/tlsproject/submit # ls -all
total 44
drwx------ 2 cs161-hc cs161  4096 Nov 18 20:37 .
drwx------ 4 cs161-hc cs161  4096 Nov 18 20:37 ..
-rw------- 1 cs161-hc cs161 21939 Nov 18 20:37 client.c
-rw------- 1 cs161-hc cs161  5938 Nov 18 20:37 tlsproj.txt
hive11 [510] ~/TLS-Implementation/tlsproject/submit # submit tlsproj
Please enter the logins of your partner(s), if any.
Enter '.' to stop.
Login: cs161-iz
Login: .
Your partners' logins are cs161-iz 
Is this correct? [yes/no] yes
Created MY.PARTNERS file.
Looking for files to turn in....
Submitting client.c.
Submitting tlsproj.txt.
The files you have submitted are:
	./MY.PARTNERS ./client.c ./tlsproj.txt 
Is this correct? [yes/no] yes
Copying submission of assignment tlsproj....
Submitted entry for partner cs161-iz.
Submission complete.
hive11 [511] ~/TLS-Implementation/tlsproject/submit # glookup -t
Submissions for cs161-hc (lateness in [+dd:hh:mm]):
         hw1: Tue Sep 16 12:15:00, Tue Sep 16 12:55:00
         hw2: Tue Sep 23 01:36:00
         hw3: Sun Sep 28 22:55:00, Tue Sep 30 14:17:00
         hw4: Wed Oct 22 05:26:00, Wed Oct 22 09:25:00
         hw5: Tue Oct 28 13:43:00, Tue Oct 28 14:01:00
              Tue Oct 28 14:54:00
         hw6: Tue Nov  4 13:52:00, Tue Nov  4 13:59:00
       proj0: Sat Sep 20 22:37:00, Sun Sep 21 16:40:00
     tlsproj: Tue Nov 18 18:57:00, Tue Nov 18 20:37:00

hive11 [512] ~/TLS-Implementation/tlsproject/submit # ll
total 44
drwx------ 2 cs161-hc cs161  4096 Nov 18 20:37 .
drwx------ 4 cs161-hc cs161  4096 Nov 18 20:37 ..
-rw------- 1 cs161-hc cs161 21939 Nov 18 20:37 client.c
-rw------- 1 cs161-hc cs161    18 Nov 18 20:37 MY.PARTNERS
-rw------- 1 cs161-hc cs161  5938 Nov 18 20:37 tlsproj.txt
hive11 [513] ~/TLS-Implementation/tlsproject/submit # ll
total 44
drwx------ 2 cs161-hc cs161  4096 Nov 18 20:37 .
drwx------ 4 cs161-hc cs161  4096 Nov 18 20:37 ..
-rw------- 1 cs161-hc cs161 21939 Nov 18 20:37 client.c
-rw------- 1 cs161-hc cs161    18 Nov 18 20:37 MY.PARTNERS
-rw------- 1 cs161-hc cs161  5938 Nov 18 20:37 tlsproj.txt
hive11 [514] ~/TLS-Implementation/tlsproject/submit # vi sub.log
hive11 [515] ~/TLS-Implementation/tlsproject/submit # cat sub.log 
Last login: Tue Nov 18 20:18:57 on ttys000
airbears2-10-142-152-197:~ jingezhang$ ssh cs161-hc@hive11.cs.berkeley.edu
cs161-hc@hive11.cs.berkeley.edu's password: 
Welcome to Ubuntu 12.04.4 LTS (GNU/Linux 3.2.0-61-generic x86_64)

 * Documentation:  https://help.ubuntu.com/

New release '14.04.1 LTS' available.
Run 'do-release-upgrade' to upgrade to it.

Last login: Tue Nov 18 20:19:00 2014 from airbears2-10-142-152-197.airbears2.1918.berkeley.edu

'cs161-hc' is using 111/2048 MB (5%) of its disk quota on /home/cc.

'cs161-hc' is using 0/20971 MB (0%) of its disk quota on /home/tmp.

(Type 'more /share/b/pub/disk.quotas' for more information.)

hive11 [501] ~ # cd TLS-Implementation/
hive11 [502] ~/TLS-Implementation # cd tlsproject/
hive11 [503] ~/TLS-Implementation/tlsproject # make
gcc -W aes.c sha256.c client.c -o client -lgmp
hive11 [504] ~/TLS-Implementation/tlsproject # ./client -i 54.148.53.246 -c client_cert.crt -d client_private.key -m client_modulus.key 
hello
^C
hive11 [505] ~/TLS-Implementation/tlsproject # ./client -i 54.148.53.246 -c client_cert.crt -d client_private.key -m client_modulus.key 
hellow
Hooray!
few
Hooray!
fewf
Hooray!
we
Hooray!
fw
eHooray!
f
Hooray!
we
fHooray!
w
eHooray!
f
wHooray!
ef
ewHooray!

fHooray!
we
Hooray!
f
wHooray!
e^C
hive11 [506] ~/TLS-Implementation/tlsproject # mkdir submit
hive11 [507] ~/TLS-Implementation/tlsproject # cp client.c tlsproj.txt submit/
hive11 [508] ~/TLS-Implementation/tlsproject # cd submit/
hive11 [509] ~/TLS-Implementation/tlsproject/submit # ls -all
total 44
drwx------ 2 cs161-hc cs161  4096 Nov 18 20:37 .
drwx------ 4 cs161-hc cs161  4096 Nov 18 20:37 ..
-rw------- 1 cs161-hc cs161 21939 Nov 18 20:37 client.c
-rw------- 1 cs161-hc cs161  5938 Nov 18 20:37 tlsproj.txt
hive11 [510] ~/TLS-Implementation/tlsproject/submit # submit tlsproj
Please enter the logins of your partner(s), if any.
Enter '.' to stop.
Login: cs161-iz
Login: .
Your partners' logins are cs161-iz 
Is this correct? [yes/no] yes
Created MY.PARTNERS file.
Looking for files to turn in....
Submitting client.c.
Submitting tlsproj.txt.
The files you have submitted are:
	./MY.PARTNERS ./client.c ./tlsproj.txt 
Is this correct? [yes/no] yes
Copying submission of assignment tlsproj....
Submitted entry for partner cs161-iz.
Submission complete.
hive11 [511] ~/TLS-Implementation/tlsproject/submit # glookup -t
Submissions for cs161-hc (lateness in [+dd:hh:mm]):
         hw1: Tue Sep 16 12:15:00, Tue Sep 16 12:55:00
         hw2: Tue Sep 23 01:36:00
         hw3: Sun Sep 28 22:55:00, Tue Sep 30 14:17:00
         hw4: Wed Oct 22 05:26:00, Wed Oct 22 09:25:00
         hw5: Tue Oct 28 13:43:00, Tue Oct 28 14:01:00
              Tue Oct 28 14:54:00
         hw6: Tue Nov  4 13:52:00, Tue Nov  4 13:59:00
       proj0: Sat Sep 20 22:37:00, Sun Sep 21 16:40:00
     tlsproj: Tue Nov 18 18:57:00, Tue Nov 18 20:37:00

hive11 [512] ~/TLS-Implementation/tlsproject/submit # 

hive11 [516] ~/TLS-Implementation/tlsproject/submit # submit tlsproj
Please enter the logins of your partner(s), if any.
Enter '.' to stop.
Login: cs161-iz
Login: .
Your partners' logins are cs161-iz 
Is this correct? [yes/no] yes
Created MY.PARTNERS file.
Looking for files to turn in....
Submitting client.c.
Submitting tlsproj.txt.
Turn in ./sub.log?  [yes/no] yes
The files you have submitted are:
	./MY.PARTNERS ./client.c ./sub.log ./tlsproj.txt 
Is this correct? [yes/no] yes
Copying submission of assignment tlsproj....
Submitted entry for partner cs161-iz.
Submission complete.
hive11 [517] ~/TLS-Implementation/tlsproject/submit # ll
total 48
drwx------ 2 cs161-hc cs161  4096 Nov 18 20:38 .
drwx------ 4 cs161-hc cs161  4096 Nov 18 20:37 ..
-rw------- 1 cs161-hc cs161 21939 Nov 18 20:37 client.c
-rw------- 1 cs161-hc cs161    18 Nov 18 20:38 MY.PARTNERS
-rw------- 1 cs161-hc cs161  2934 Nov 18 20:38 sub.log
-rw------- 1 cs161-hc cs161  5938 Nov 18 20:37 tlsproj.txt
hive11 [518] ~/TLS-Implementation/tlsproject/submit # mv sub.log ../
hive11 [519] ~/TLS-Implementation/tlsproject/submit # ll
total 44
drwx------ 2 cs161-hc cs161  4096 Nov 18 20:38 .
drwx------ 4 cs161-hc cs161  4096 Nov 18 20:38 ..
-rw------- 1 cs161-hc cs161 21939 Nov 18 20:37 client.c
-rw------- 1 cs161-hc cs161    18 Nov 18 20:38 MY.PARTNERS
-rw------- 1 cs161-hc cs161  5938 Nov 18 20:37 tlsproj.txt
hive11 [520] ~/TLS-Implementation/tlsproject/submit # submit tlsproj
Please enter the logins of your partner(s), if any.
Enter '.' to stop.
Login: cs161-iz
Login: .
Your partners' logins are cs161-iz 
Is this correct? [yes/no] yes
Created MY.PARTNERS file.
Looking for files to turn in....
Submitting client.c.
Submitting tlsproj.txt.
The files you have submitted are:
	./MY.PARTNERS ./client.c ./tlsproj.txt 
Is this correct? [yes/no] yes
Copying submission of assignment tlsproj....
There already seems to be a submission for this time
There was some problem submitting to the class account.
Assignment NOT SUBMITTED.
hive11 [521] ~/TLS-Implementation/tlsproject/submit # glookup -t
Submissions for cs161-hc (lateness in [+dd:hh:mm]):
         hw1: Tue Sep 16 12:15:00, Tue Sep 16 12:55:00
         hw2: Tue Sep 23 01:36:00
         hw3: Sun Sep 28 22:55:00, Tue Sep 30 14:17:00
         hw4: Wed Oct 22 05:26:00, Wed Oct 22 09:25:00
         hw5: Tue Oct 28 13:43:00, Tue Oct 28 14:01:00
              Tue Oct 28 14:54:00
         hw6: Tue Nov  4 13:52:00, Tue Nov  4 13:59:00
       proj0: Sat Sep 20 22:37:00, Sun Sep 21 16:40:00
     tlsproj: Tue Nov 18 18:57:00, Tue Nov 18 20:37:00
              Tue Nov 18 20:38:00

hive11 [522] ~/TLS-Implementation/tlsproject/submit # submit tlsproj
Please enter the logins of your partner(s), if any.
Enter '.' to stop.
Login: cs161-iz
Login: .
Your partners' logins are cs161-iz 
Is this correct? [yes/no] yes
Created MY.PARTNERS file.
Looking for files to turn in....
Submitting client.c.
Submitting tlsproj.txt.
The files you have submitted are:
	./MY.PARTNERS ./client.c ./tlsproj.txt 
Is this correct? [yes/no] yes
Copying submission of assignment tlsproj....
Submitted entry for partner cs161-iz.
Submission complete.
hive11 [523] ~/TLS-Implementation/tlsproject/submit # glookup -t
Submissions for cs161-hc (lateness in [+dd:hh:mm]):
         hw1: Tue Sep 16 12:15:00, Tue Sep 16 12:55:00
         hw2: Tue Sep 23 01:36:00
         hw3: Sun Sep 28 22:55:00, Tue Sep 30 14:17:00
         hw4: Wed Oct 22 05:26:00, Wed Oct 22 09:25:00
         hw5: Tue Oct 28 13:43:00, Tue Oct 28 14:01:00
              Tue Oct 28 14:54:00
         hw6: Tue Nov  4 13:52:00, Tue Nov  4 13:59:00
       proj0: Sat Sep 20 22:37:00, Sun Sep 21 16:40:00
     tlsproj: Tue Nov 18 18:57:00, Tue Nov 18 20:37:00
              Tue Nov 18 20:38:00, Tue Nov 18 20:39:00

hive11 [524] ~/TLS-Implementation/tlsproject/submit # ls -all
total 44
drwx------ 2 cs161-hc cs161  4096 Nov 18 20:39 .
drwx------ 4 cs161-hc cs161  4096 Nov 18 20:38 ..
-rw------- 1 cs161-hc cs161 21939 Nov 18 20:37 client.c
-rw------- 1 cs161-hc cs161    18 Nov 18 20:39 MY.PARTNERS
-rw------- 1 cs161-hc cs161  5938 Nov 18 20:37 tlsproj.txt
hive11 [525] ~/TLS-Implementation/tlsproject/submit # cat client.c 
/*
 * sig_client.c
 *
 * Author: Alec Guertin
 * University of California, Berkeley
 * CS 161 - Computer Security
 * Fall 2014 Semester
 * Project 1
 */

#include "client.h"

/* The file descriptor for the socket connected to the server. */
static int sockfd;

static void perform_rsa(mpz_t result, mpz_t message, mpz_t d, mpz_t n);
static int hex_to_ascii(char a, char b);
static int hex_to_int(char a);
static void usage();
static void kill_handler(int signum);
static int random_int();
static void cleanup();

int main(int argc, char **argv) {
  int err, option_index, c, clientlen, counter;
  unsigned char rcv_plaintext[AES_BLOCK_SIZE];
  unsigned char rcv_ciphertext[AES_BLOCK_SIZE];
  unsigned char send_plaintext[AES_BLOCK_SIZE];
  unsigned char send_ciphertext[AES_BLOCK_SIZE];
  aes_context enc_ctx, dec_ctx;
  in_addr_t ip_addr;
  struct sockaddr_in server_addr;
  FILE *c_file, *d_file, *m_file;
  ssize_t read_size, write_size;
  struct sockaddr_in client_addr;
  tls_msg err_msg, send_msg, rcv_msg;
  mpz_t client_exp, client_mod;
  fd_set readfds;
  struct timeval tv;

  c_file = d_file = m_file = NULL;

  mpz_init(client_exp);
  mpz_init(client_mod);

  /*
   * This section is networking code that you don't need to worry about.
   * Look further down in the function for your part.
   */

  memset(&ip_addr, 0, sizeof(in_addr_t));

  option_index = 0;
  err = 0;

  static struct option long_options[] = {
    {"ip", required_argument, 0, 'i'},
    {"cert", required_argument, 0, 'c'},
    {"exponent", required_argument, 0, 'd'},
    {"modulus", required_argument, 0, 'm'},
    {0, 0, 0, 0},
  };

  while (1) {
    c = getopt_long(argc, argv, "c:i:d:m:", long_options, &option_index);
    if (c < 0) {
      break;
    }
    switch(c) {
    case 0:
      usage();
      break;
    case 'c':
      c_file = fopen(optarg, "r");
      if (c_file == NULL) {
	perror("Certificate file error");
	exit(1);
      }
      break;
    case 'd':
      d_file = fopen(optarg, "r");
      if (d_file == NULL) {
	perror("Exponent file error");
	exit(1);
      }
      break;
    case 'i':
      ip_addr = inet_addr(optarg);
      break;
    case 'm':
      m_file = fopen(optarg, "r");
      if (m_file == NULL) {
	perror("Modulus file error");
	exit(1);
      }
      break;
    case '?':
      usage();
      break;
    default:
      usage();
      break;
    }
  }

  if (d_file == NULL || c_file == NULL || m_file == NULL) {
    usage();
  }
  if (argc != 9) {
    usage();
  }

  mpz_inp_str(client_exp, d_file, 0);
  mpz_inp_str(client_mod, m_file, 0);

  signal(SIGTERM, kill_handler);

  sockfd = socket(AF_INET, SOCK_STREAM, 0);
  if (sockfd < 0) {
    perror("Could not open socket");
    exit(1);
  }

  memset(&server_addr, 0, sizeof(struct sockaddr_in));
  server_addr.sin_family = AF_INET;
  server_addr.sin_addr.s_addr = ip_addr;
  server_addr.sin_port = htons(HANDSHAKE_PORT);
  err = connect(sockfd, (struct sockaddr *) &server_addr, sizeof(server_addr));
  if (err < 0) {
    perror("Could not bind socket");
    cleanup();
  }

  // YOUR CODE HERE
  // IMPLEMENT THE TLS HANDSHAKE
  int send_message_int, receive_messge_int;
  /* error handling (To be continued) */
  // ********************************************************************
  // ********************************************************************
  // ********************************************************************
  
  // Whenever send or receive, need to check this feedback
  int feedback;
  //  =============== [Send] Client Hello =======================
  hello_message client_hello_message;
  int client_random;
  int server_random;
  memset(&client_hello_message, 0, HELLO_MSG_SIZE);

  client_random = random_int();
  client_hello_message.type = CLIENT_HELLO;
  client_hello_message.random = client_random;
  client_hello_message.cipher_suite = TLS_RSA_WITH_AES_128_ECB_SHA256;
  feedback = send_tls_message(sockfd, &client_hello_message, HELLO_MSG_SIZE);
  if (feedback != ERR_OK){
    perror("[CLIENT_HELLO]: can't send tls message");
    cleanup();  
  }

  //  =============== [Receive] Sever Hello =======================
  hello_message server_hello_message;
  memset(&server_hello_message, 0, HELLO_MSG_SIZE);
  feedback = receive_tls_message(sockfd, &server_hello_message, HELLO_MSG_SIZE, SERVER_HELLO);
  if (feedback != ERR_OK){
    perror("[SERVER_HELLO]: can't receive tls message");
    cleanup();    
  }
  server_random = server_hello_message.random;
  int server_cipher_suite = server_hello_message.cipher_suite;
  if (server_cipher_suite != client_hello_message.cipher_suite) {
    perror("[different cipher_suite]: cipher suites doesn't match");
    cleanup();
  }

  //  =============== [Send] Client Certificate ================
  mpz_t client_certificate_mpz;
  cert_message client_certificate;
  int byte_read;
  mpz_init(client_certificate_mpz);
  // May need to verify whether we connect to the correct server(i.e.torus.ce.berkeley.edu).
  memset(&client_certificate, 0, CERT_MSG_SIZE);
  client_certificate.type = CLIENT_CERTIFICATE;
  fread(client_certificate.cert, RSA_MAX_LEN, 1, c_file);
  feedback = send_tls_message(sockfd, &client_certificate, CERT_MSG_SIZE);
  if (feedback != ERR_OK){
    perror("[CLIENT CERTIFICATE]: can't send tls message");
    cleanup();
  }

  //  =============== [Receive] Server Certificate ================
  cert_message server_certificate;
  mpz_t decrypted_sever_cert_mpz;
  mpz_t ca_exponent;
  mpz_t ca_modulus;
  mpz_t server_public_key_exponent;
  mpz_t server_public_key_modulus;
  char decrypted_server_cert [RSA_MAX_LEN];

  memset(&server_certificate, 0, CERT_MSG_SIZE);
  mpz_init(decrypted_sever_cert_mpz);
  mpz_init(ca_exponent);
  mpz_init(ca_modulus);
  mpz_init(server_public_key_exponent);
  mpz_init(server_public_key_modulus);
  memset(decrypted_server_cert, 0, RSA_MAX_LEN);

  feedback = receive_tls_message(sockfd, &server_certificate, CERT_MSG_SIZE, SERVER_CERTIFICATE);
  if (feedback != ERR_OK){
    perror("[SERVER CERTIFICATE]: can't receive tls message");
    cleanup();
  }
  // May need to verify whether we connect to the correct server(i.e.torus.ce.berkeley.edu).
  // Decrypt Server Certificate
  mpz_set_str(ca_exponent, CA_EXPONENT, 0);
  mpz_set_str(ca_modulus, CA_MODULUS, 0);
  decrypt_cert(decrypted_sever_cert_mpz, &server_certificate, ca_exponent, ca_modulus);
  mpz_get_ascii(decrypted_server_cert, decrypted_sever_cert_mpz);                       // Convert mpz to char array
  feedback = get_cert_exponent(server_public_key_exponent, decrypted_server_cert);
  if (feedback != ERR_OK) {
    perror("[get_cert_exponent failture]: can't get cert_exponent");
    cleanup();
  }
  feedback = get_cert_modulus(server_public_key_modulus, decrypted_server_cert);
  if (feedback != ERR_OK) {
    perror("[get_cert_modulus failture]: can't get cert_modulus");
    cleanup();
  }


  //  =============== [Send] E_server_public_key (Premaster Secret) ================
  // Construct encrypted(premaster secret)
  mpz_t premaster_secret_encrypted, premaster_secret_mpz;
  int premaster_secret;
  char premaster[SHA_BLOCK_SIZE];
  ps_msg encrypted_ps_message;
  mpz_init(premaster_secret_encrypted);
  mpz_init(premaster_secret_mpz); 
  memset(&encrypted_ps_message, 0, PS_MSG_SIZE);
  
  // Generate and Covert Premaster Secret to mpz
  premaster_secret = random_int();
  sprintf(premaster, "%d", premaster_secret);
  mpz_set_str(premaster_secret_mpz, premaster, 10);
  perform_rsa(premaster_secret_encrypted, premaster_secret_mpz, server_public_key_exponent, server_public_key_modulus);
  encrypted_ps_message.type = PREMASTER_SECRET;
  mpz_get_str(encrypted_ps_message.ps, HEX_BASE, premaster_secret_encrypted);
  feedback = send_tls_message(sockfd, &encrypted_ps_message, PS_MSG_SIZE);
  if (feedback != ERR_OK) {
    perror("[E_server_public_key (Premaster secret)]: can't send tls message");
    cleanup();
  }
  
  //  =============== [Receive] E_client_public_key (Master Secret) ================
  ps_msg encrypted_server_ms_message;
  mpz_t decrypted_ms;
  mpz_t master_secret_mpz;
  unsigned long long master_secret_long;
  unsigned char master_secret[SHA_BLOCK_SIZE];
  int result;
  memset(&encrypted_server_ms_message, 0, PS_MSG_SIZE);
  mpz_init(decrypted_ms);
  memset(master_secret, 0, SHA_BLOCK_SIZE);
  mpz_init(master_secret_mpz);
  feedback = receive_tls_message(sockfd, &encrypted_server_ms_message, PS_MSG_SIZE, VERIFY_MASTER_SECRET);
  if (feedback != ERR_OK) {
    perror("[E_client_public_key (master secret)]: can't receive tls message");
    cleanup();
  }

  decrypt_verify_master_secret(decrypted_ms, &encrypted_server_ms_message, client_exp, client_mod);
  compute_master_secret(premaster_secret, client_random, server_random, master_secret);
  char* master_secret_str = hex_to_str(master_secret, SHA_BLOCK_SIZE);
  mpz_set_str(master_secret_mpz, master_secret_str, HEX_BASE);
  result = mpz_cmp(master_secret_mpz, decrypted_ms);
  if (result != 0) {
    perror("Decrypted server master secret doesn't match computed master secret!");
    cleanup();
  }
  
  free(master_secret_str);
  // ********************************************************************
  // ********************************************************************
  // ********************************************************************

  /*
   * START ENCRYPTED MESSAGES
   */

  memset(send_plaintext, 0, AES_BLOCK_SIZE);
  memset(send_ciphertext, 0, AES_BLOCK_SIZE);
  memset(rcv_plaintext, 0, AES_BLOCK_SIZE);
  memset(rcv_ciphertext, 0, AES_BLOCK_SIZE);

  memset(&rcv_msg, 0, TLS_MSG_SIZE);

  aes_init(&enc_ctx);
  aes_init(&dec_ctx);
  
  // YOUR CODE HERE
  // SET AES KEYS

  aes_setkey_enc(&enc_ctx, master_secret, AES_BLOCK_SIZE * BYTE_SIZE);
  aes_setkey_dec(&dec_ctx, master_secret, AES_BLOCK_SIZE * BYTE_SIZE);

  fcntl(STDIN_FILENO, F_SETFL, O_NONBLOCK);
  /* Send and receive data. */
  while (1) {
    FD_ZERO(&readfds);
    FD_SET(STDIN_FILENO, &readfds);
    FD_SET(sockfd, &readfds);
    tv.tv_sec = 2;
    tv.tv_usec = 10;

    select(sockfd+1, &readfds, NULL, NULL, &tv);
    if (FD_ISSET(STDIN_FILENO, &readfds)) {
      counter = 0;
      memset(&send_msg, 0, TLS_MSG_SIZE);
      send_msg.type = ENCRYPTED_MESSAGE;
      memset(send_plaintext, 0, AES_BLOCK_SIZE);
      read_size = read(STDIN_FILENO, send_plaintext, AES_BLOCK_SIZE);
      while (read_size > 0 && (unsigned int) counter + AES_BLOCK_SIZE < TLS_MSG_SIZE - INT_SIZE) {
	if (read_size > 0) {
	  err = aes_crypt_ecb(&enc_ctx, AES_ENCRYPT, send_plaintext, send_ciphertext);
	  memcpy(send_msg.msg + counter, send_ciphertext, AES_BLOCK_SIZE);
	  counter += AES_BLOCK_SIZE;
	}
	memset(send_plaintext, 0, AES_BLOCK_SIZE);
	read_size = read(STDIN_FILENO, send_plaintext, AES_BLOCK_SIZE);
      }
      write_size = write(sockfd, &send_msg, INT_SIZE+counter+AES_BLOCK_SIZE);
      if (write_size < 0) {
	perror("Could not write to socket");
	cleanup();
      }
    } else if (FD_ISSET(sockfd, &readfds)) {
      memset(&rcv_msg, 0, TLS_MSG_SIZE);
      memset(rcv_ciphertext, 0, AES_BLOCK_SIZE);
      read_size = read(sockfd, &rcv_msg, TLS_MSG_SIZE);
      if (read_size > 0) {
	if (rcv_msg.type != ENCRYPTED_MESSAGE) {
	  goto out;
	}
	memcpy(rcv_ciphertext, rcv_msg.msg, AES_BLOCK_SIZE);
	counter = 0;
	while ((unsigned int) counter < read_size - INT_SIZE - AES_BLOCK_SIZE) {
	  aes_crypt_ecb(&dec_ctx, AES_DECRYPT, rcv_ciphertext, rcv_plaintext);
	  printf("%s", rcv_plaintext);
	  counter += AES_BLOCK_SIZE;
	  memcpy(rcv_ciphertext, rcv_msg.msg+counter, AES_BLOCK_SIZE);
	}
	printf("\n");
      }
    }

  }

 out:
  close(sockfd);
  mpz_clear(client_exp);
  mpz_clear(client_mod);
  mpz_clear(client_certificate_mpz);
  mpz_clear(decrypted_sever_cert_mpz);
  mpz_clear(ca_exponent);
  mpz_clear(ca_modulus);
  mpz_clear(premaster_secret_encrypted);
  mpz_clear(server_public_key_exponent);
  mpz_clear(server_public_key_modulus);
  mpz_clear(premaster_secret_mpz);
  mpz_clear(decrypted_ms);
  mpz_clear(master_secret_mpz);
  return 0;
}

/*
 * \brief                  Decrypts the certificate in the message cert.
 *
 * \param decrypted_cert   This mpz_t stores the final value of the binary
 *                         for the decrypted certificate. Write the end
 *                         result here.
 * \param cert             The message containing the encrypted certificate.
 * \param key_exp          The exponent of the public key for decrypting
 *                         the certificate.
 * \param key_mod          The modulus of the public key for decrypting
 *                         the certificate.
 */
void
decrypt_cert(mpz_t decrypted_cert, cert_message *cert, mpz_t key_exp, mpz_t key_mod)
{
  // YOUR CODE HERE
  mpz_t certificate;
  mpz_init(certificate);
  mpz_set_str(certificate, cert->cert, 0);
  perform_rsa(decrypted_cert, certificate, key_exp, key_mod);
  mpz_clear(certificate);
}

/*
 * \brief                  Decrypts the master secret in the message ms_ver.
 *
 * \param decrypted_ms     This mpz_t stores the final value of the binary
 *                         for the decrypted master secret. Write the end
 *                         result here.
 * \param ms_ver           The message containing the encrypted master secret.
 * \param key_exp          The exponent of the public key for decrypting
 *                         the master secret.
 * \param key_mod          The modulus of the public key for decrypting
 *                         the master secret.
 */
void
decrypt_verify_master_secret(mpz_t decrypted_ms, ps_msg *ms_ver, mpz_t key_exp, mpz_t key_mod)
{
  // YOUR CODE HERE
  mpz_t premaster;
  mpz_init(premaster);
  mpz_set_str(premaster, ms_ver->ps, SHA_BLOCK_SIZE);
  perform_rsa(decrypted_ms, premaster, key_exp, key_mod);
  mpz_clear(premaster);
}

/*
 * \brief                  Computes the master secret.
 *
 * \param ps               The premaster secret.
 * \param client_random    The random value from the client hello.
 * \param server_random    The random value from the server hello.
 * \param master_secret    A pointer to the final value of the master secret.
 *                         Write the end result here.
 */
void
compute_master_secret(int ps, int client_random, int server_random, unsigned char *master_secret)
{
  // YOUR CODE HERE
  SHA256_CTX ctx;
  sha256_init(&ctx);
  unsigned char data[sizeof(int)];
  unsigned char data1[sizeof(int)];
  unsigned char data2[sizeof(int)];
  unsigned char data3[sizeof(int)];

  memcpy(data, &ps, sizeof(ps));
  sha256_update(&ctx, data, (int) sizeof(data));

  memcpy(data1, &client_random, sizeof(client_random));
  sha256_update(&ctx, data1, (int) sizeof(data1));

  memcpy(data2, &server_random, sizeof(server_random));
  sha256_update(&ctx, data2, (int) sizeof(data2));

  memcpy(data3, &ps, sizeof(ps));
  sha256_update(&ctx, data3, (int) sizeof(data3));

  sha256_final(&ctx, (unsigned char*) master_secret);
}

/*
 * \brief                  Sends a message to the connected server.
 *                         Returns an error code.
 *
 * \param socketno         A file descriptor for the socket to send
 *                         the message on.
 * \param msg              A pointer to the message to send.
 * \param msg_len          The length of the message in bytes.
 */
int
send_tls_message(int socketno, void *msg, int msg_len)
{
  // YOUR CODE HERE
  int n = 0;
  n = write(socketno, msg, (size_t) msg_len);
  if (n < 0 || n != msg_len){
    return ERR_FAILURE;
  }else{
    return ERR_OK;
  }
}

/*
 * \brief                  Receieves a message from the connected server.
 *                         Returns an error code.
 *
 * \param socketno         A file descriptor for the socket to receive
 *                         the message on.
 * \param msg              A pointer to where to store the received message.
 * \param msg_len          The length of the message in bytes.
 * \param msg_type         The expected type of the message to receive.
 */
int
receive_tls_message(int socketno, void *msg, int msg_len, int msg_type)
{
  // YOUR CODE HERE
  // Need to deal with the case that receive message is ERROR message
  int n = 0;
  // Mesage length probabaly large than MAX_REc
  // Need while loop here
  void *msg_ptr = msg;
  int remain_bytes = msg_len;
  int receive_bype = 0;
  while (remain_bytes > MAX_RECEIVE_BYTES){
    n = read(socketno, msg_ptr, MAX_RECEIVE_BYTES);
    if (n < 0){
      return ERR_FAILURE;
    }
    receive_bype += n;
    remain_bytes -= n;
    msg_ptr += n;
  }
  n = read(socketno, msg_ptr, (size_t) remain_bytes);
  if (n < 0){
    return ERR_FAILURE;
  }
  receive_bype += n;
  if (receive_bype != msg_len){
    return ERR_FAILURE;
  }
  int *msg_type_int = msg;
  if (msg_type != *msg_type_int) {
    return ERR_FAILURE;
  }
  return ERR_OK;
}


/*
 * \brief                Encrypts/decrypts a message using the RSA algorithm.
 *
 * \param result         a field to populate with the result of your RSA calculation.
 * \param message        the message to perform RSA on. (probably a cert in this case)
 * \param e              the encryption key from the key_file passed in through the
 *                       command-line arguments
 * \param n              the modulus for RSA from the modulus_file passed in through
 *                       the command-line arguments
 *
 * Fill in this function with your proj0 solution or see staff solutions.
 */
static void
perform_rsa(mpz_t result, mpz_t message, mpz_t d, mpz_t n)
{
  int hex = HEX_BASE;
  mpz_t zero, one, two, tmp;
  char zero_str[] = "0";
  char one_str[] = "1";
  char two_str[] = "2";

  mpz_init(zero);
  mpz_init(one);
  mpz_init(two);
  mpz_init(tmp);

  mpz_set_str(zero, zero_str, hex);
  mpz_set_str(one, one_str, hex);
  mpz_set_str(two, two_str, hex);
  mpz_set_str(tmp, zero_str, hex);
  
  // initilize result = 1;
  mpz_add(result, zero, one);

  while (mpz_cmp(d, zero) > 0){
    mpz_mod(tmp, d, two);
    if (mpz_cmp(tmp, one) == 0) {
      // result = (result * message) % n;
      mpz_mul(tmp, result, message);
      mpz_mod(result, tmp, n);
      // d--;
      mpz_sub(d, d, one);
    }
    // d = d/2;
    mpz_div(d, d, two);
    // message = (message * message) % n;
    mpz_mul(tmp, message, message);
    mpz_mod(message, tmp, n);
  }
  mpz_clear(zero);
  mpz_clear(one);
  mpz_clear(two);
  mpz_clear(tmp);
}


/* Returns a pseudo-random integer. */
static int
random_int()
{
  srand(time(NULL));
  return rand();
}

/*
 * \brief                 Returns ascii string from a number in mpz_t form.
 *
 * \param output_str      A pointer to the output string.
 * \param input           The number to convert to ascii.
 */
void
mpz_get_ascii(char *output_str, mpz_t input)
{
  int i,j;
  char *result_str;
  result_str = mpz_get_str(NULL, HEX_BASE, input);
  i = 0;
  j = 0;
  while (result_str[i] != '\0') {
    output_str[j] = hex_to_ascii(result_str[i], result_str[i+1]);
    j += 1;
    i += 2;
  }
}

/*
 * \brief                  Returns a pointer to a string containing the
 *                         characters representing the input hex value.
 *
 * \param data             The input hex value.
 * \param data_len         The length of the data in bytes.
 */
char
*hex_to_str(char *data, int data_len)
{
  int i;
  char *output_str = calloc(1+2*data_len, sizeof(char));
  for (i = 0; i < data_len; i += 1) {
    snprintf(output_str+2*i, 3, "%02X", (unsigned int) (data[i] & 0xFF));
  }
  return output_str;
}

/* Return the public key exponent given the decrypted certificate as string. */
int
get_cert_exponent(mpz_t result, char *cert)
{
  int err;
  char *srch, *srch2;
  char exponent[RSA_MAX_LEN/2];
  memset(exponent, 0, RSA_MAX_LEN/2);
  srch = strchr(cert, '\n');
  if (srch == NULL) {
    return ERR_FAILURE;
  }
  srch += 1;
  srch = strchr(srch, '\n');
  if (srch == NULL) {
    return ERR_FAILURE;
  }
  srch += 1;
  srch = strchr(srch, '\n');
  if (srch == NULL) {
    return ERR_FAILURE;
  }
  srch += 1;
  srch = strchr(srch, ':');
  if (srch == NULL) {
    return ERR_FAILURE;
  }
  srch += 2;
  srch2 = strchr(srch, '\n');
  if (srch2 == NULL) {
    return ERR_FAILURE;
  }
  strncpy(exponent, srch, srch2-srch);
  err = mpz_set_str(result, exponent, 0);
  if (err == -1) {
    return ERR_FAILURE;
  }
  return ERR_OK;
}

/* Return the public key modulus given the decrypted certificate as string. */
int
get_cert_modulus(mpz_t result, char *cert)
{
  int err;
  char *srch, *srch2;
  char modulus[RSA_MAX_LEN/2];
  memset(modulus, 0, RSA_MAX_LEN/2);
  srch = strchr(cert, '\n');
  if (srch == NULL) {
    return ERR_FAILURE;
  }
  srch += 1;
  srch = strchr(srch, '\n');
  if (srch == NULL) {
    return ERR_FAILURE;
  }
  srch += 1;
  srch = strchr(srch, ':');
  if (srch == NULL) {
    return ERR_FAILURE;
  }
  srch += 2;
  srch2 = strchr(srch, '\n');
  if (srch2 == NULL) {
    return ERR_FAILURE;
  }
  strncpy(modulus, srch, srch2-srch);
  err = mpz_set_str(result, modulus, 0);
  if (err == -1) {
    return ERR_FAILURE;
  }
  return ERR_OK;
}

/* Prints the usage string for this program and exits. */
static void
usage()
{
    printf("./client -i <server_ip_address> -c <certificate_file> -m <modulus_file> -d <exponent_file>\n");
    exit(1);
}

/* Catches the signal from C-c and closes connection with server. */
static void
kill_handler(int signum)
{
  if (signum == SIGTERM) {
    cleanup();
  }
}

/* Converts the two input hex characters into an ascii char. */
static int
hex_to_ascii(char a, char b)
{
    int high = hex_to_int(a) * 16;
    int low = hex_to_int(b);
    return high + low;
}

/* Converts a hex value into an int. */
static int
hex_to_int(char a)
{
    if (a >= 97) {
	a -= 32;
    }
    int first = a / 16 - 3;
    int second = a % 16;
    int result = first*10 + second;
    if (result > 9) {
	result -= 1;
    }
    return result;
}

/* Closes files and exits the program. */
static void
cleanup()
{
  close(sockfd);
  exit(1);
}
hive11 [526] ~/TLS-Implementation/tlsproject/submit # cat tlsproj.txt 
My name: Jinge Zhang
My SID: 23857461
My section: Section 105
My TA: Arjun Baokar

Partner name: Xinran Guo
Partner SID: 24718837
Partner section: Section 102
Partner TA: Neil Gong


1. 
The attacker could intercept the client_hello message and change the type to something else like ERROR_MESSAGE and send it to the server so that the server would send back an ERROR_MESSAGE to the client that the connections fails. Then, we assume client would keep trying to send his or her client_hello message if the client keeps receive ERROR_MESSAGE since the client would think he or she fails to connect with the server. Thus, as the client keeps sending the hello_message and the attacker keeps changing its type to something else, the server would use up all of its service and terminate. So we succeed in Dos Attack on the client.

2. 
- “Random number" chosen by taking advantage of  `srand(time(NULL))`, time(NULL) set the seed of “srand” (Pseudo-Random Number Generator) based on the current time in second.
- Yes, attacker knows the seed of PRNG is based on time of calling random_int(). As long as attacker observe the time that client call random_int(), they can pass that time to generate the same random number, which means attacker get chance to know client generate “premaster secret” in TLS protocol.
- MITM: Suppose attacker know our master secret generate formula (Master Secret = H(PS||clienthello.random||serverhello.random||PS))
Since “client hello” and “server hello” are not encrypted, MITM can easily get client_random and server_random by extract server hello and client hello package. In addition, as we observe, “server_random” (server send to client) and “premaster secret” (client call random_int() to generate) are mostly the same. it indicates that attacker have high possibility to guess correct premaster secret. Knowing master secret generate formula, attacker can easily calculate master secret and break our encryption.

3. 
Since TLS protocol we implemented has a type field sent in plaintext, and “client hello” message and “server hello” message are not encrypted. Suppose a man in the middle in the client-server connection, they can do following actions,
	1. Client sends “client hello” with cipher suites they want to communicate with server.
	2. Attacker can extract that “client hello” by checking message type if equal to “CLIENT_HELLO 0x1”
	3. Then attacker can check if the cipher suite in “client hello” message is weaker one they want.
	4. If not, they can simply drop “client hello” and create a fake server error message ( probably states error occurred by compatibility of cipher suites) to terminate the connection between client and server
	5. Client will attempt to connect by sending client hello again and probably using different cipher suite.
	6. Attacker keeps checking and dropping those “client hello” messages until they see client use the weak cipher suite they want. then they pass this “client hello” to server.
Above scenario shows one of possible downgrade attacks that attacker can successfully force client to downgrade to weak cipher suite.

Suggested adaptation:
Suppose attacker can force the client to use downgrade cipher suite to do first four steps of handshake (i.e. Client hello, Server Hello, Client certificate, and Server Certificate)
After client received “Server Certificate”,  we can add additional steps to attempt to upgrade cipher suite by using RSA with server_public_key to encrypt the stronger cipher suite [i.e. E_server_public_key (stronger Cipher Suite)]. We configure the server such that it only accepts the most recent compatible protocol version for every client, respectively. Thus, the rest of the handshake steps would use the stronger cipher suite.

4. (Extra Credit)
(1). Attacker in the middle of client-server handshake process can create some fake ERROR_MESSAGE (message type = 0x01) and send to the server such that server would output “unexpected message” that will terminate client-server connection.
[Fix]: Server wait amount of time if the expect message arrive

(2). Attacker can create large amount of different client_hello messages by generating different random numbers at same time, which start a DoS attack to server.
[Fix]: Defect the ip address that sending lots of client_hello message, and default block those connect request.

(3). Do MITM on client certificate such that attacker can send the its own certificate to do the rest of the handshake, given the information that the attacker could know the time when client sends its client_hello and when receives the server_hello to generate the client_random and server_random accordingly.
[Fix]: We can modify the handshake step on sending client certificate such that we sign the client certificate by CA and send it the server, where server asks CA to decrypt that message and check whether the decryption of that message is the client certificate. The server sends the server certificate to the client if it is exactly the client certificate.

(4). Attacker can replay the same message(i.e. a request to transfer money) by keeping sending it.
[Fix]: Every time after the client sends a message to the server, the client should be forced to re-authenticate its identity by starting the handshake on the step where client sends E_server_public_key(Premaster Secret).

(5) We observe client random, sever random, premaster secret are the same sometime, and sever random and premaster secret are almost always the same. it is because random_int() changes seed base on current time. TLS handshake can be completed within one second, it has high possibility to generate the same random number, which is big issue for this protocol.
[Fix]: before we call random_int(), add method to let program sleep 1~2 second to make sure we have different seed for srand.hive11 [527] ~/TLS-Implementation/tlsproject/submit # ll
total 44
drwx------ 2 cs161-hc cs161  4096 Nov 18 20:39 .
drwx------ 4 cs161-hc cs161  4096 Nov 18 20:38 ..
-rw------- 1 cs161-hc cs161 21939 Nov 18 20:37 client.c
-rw------- 1 cs161-hc cs161    18 Nov 18 20:39 MY.PARTNERS
-rw------- 1 cs161-hc cs161  5938 Nov 18 20:37 tlsproj.txt
hive11 [528] ~/TLS-Implementation/tlsproject/submit # cat MY.PARTNERS 
cs161-hc cs161-iz
hive11 [529] ~/TLS-Implementation/tlsproject/submit # ll
total 44
drwx------ 2 cs161-hc cs161  4096 Nov 18 20:39 .
drwx------ 4 cs161-hc cs161  4096 Nov 18 20:38 ..
-rw------- 1 cs161-hc cs161 21939 Nov 18 20:37 client.c
-rw------- 1 cs161-hc cs161    18 Nov 18 20:39 MY.PARTNERS
-rw------- 1 cs161-hc cs161  5938 Nov 18 20:37 tlsproj.txt
hive11 [530] ~/TLS-Implementation/tlsproject/submit # 

